#include "MeMCore.h"
#include <SoftwareSerial.h>


#define TURNDURATION 2.92
#define left -90
#define right 90
#define around 180
#define REDLEDSTATE 1
#define GREENLEDSTATE 2
#define BLUELEDSTATE 3
#define NOLEDSTATE 0
#define oneduration 600
#define RED -90
#define GREEN 90
#define ORANGE 180
#define PURPLE -2
#define BLUE 2
#define WHITE 0
#define REDLED 1
#define GREENLED 2
#define BLUELED 3
#define NOLED 0
#define IR_IN A3
#define COLOR_IN A0
#define DEFAULT_LED_ON_DURATION 100
#define vleft -240
#define vright 255



struct Color_sensor 
{
  int current[3];
  int referencecolor[6][3] = 
  { //RBG
    {381, 521, 560}, //red
    {522, 351, 402}, //blue
    {361, 503, 505}, //orange
    {515, 445, 407}, //green
    {490, 409, 487}, //purple
    {351, 307, 325}  //white
  };
  
  void light_led (char color = NOLED) 
  {
    if (color == REDLED) 
    {
      digitalWrite(A1, HIGH);
      digitalWrite(A2, LOW);
      delay(DEFAULT_LED_ON_DURATION);
      return; 
    }
    if (color == BLUELED) 
    {
      digitalWrite(A1, LOW);
      digitalWrite(A2, HIGH);
      delay(DEFAULT_LED_ON_DURATION);
      return; 
    }
    if (color == GREENLED) 
    {
      digitalWrite(A1, HIGH);
      digitalWrite(A2, HIGH);
      delay(DEFAULT_LED_ON_DURATION);
      return; 
    }   
    digitalWrite(A1, LOW);
    digitalWrite(A2, LOW);
    return; 
  }

  void read_color () 
  {
    light_led(REDLED);
    current[0] = analogRead(COLOR_IN);
    Serial.print(current[0]);
    delay(DEFAULT_LED_ON_DURATION);
    light_led(BLUELED);
    current[1] = analogRead(COLOR_IN);
    delay(DEFAULT_LED_ON_DURATION);
    light_led(GREENLED);
    delay(DEFAULT_LED_ON_DURATION);
    current[2] = analogRead(COLOR_IN);
    Serial.println(current[2]);
    light_led();
  }
  
  int find_tad (int n) 
  {
    int tad = 0;
    for (int i = 0; i < 3; i += 1) 
    {
      tad += abs(referencecolor[n][i] - current[i]);
     
    } 
    return tad;
  }
  
  char color_picker ()
  { 
    read_color();
    char pick = 0;
    int min = find_tad(0);
    for (char i = 1; i < 6; i += 1)
    {
      int tad = find_tad(i);
      if (tad < min)
      {
        pick = i;
        min = tad;
      }
    }
    return pick;  
  }
  
} color_sensor;

MeDCMotor motorleft(M1);
MeDCMotor motorright(M2);
MeLineFollower linesensor(PORT_1);  //D11, D12
MeUltrasonicSensor ultrasonic(PORT_2);  //D09, D10

MeBuzzer buzzer;



int rightdistance;
int newrightdistance;
int leftdistance;
int newleftdistance;




int ledstate = NOLEDSTATE;

void lightled() {
  if (ledstate == REDLEDSTATE) {
    digitalWrite(A1, HIGH);
    digitalWrite(A2, LOW);
    return;    
  }
  if (ledstate == BLUELEDSTATE) {
    digitalWrite(A1, LOW);
    digitalWrite(A2, HIGH);
    return;  
  } 
  if (ledstate == GREENLEDSTATE) {
    digitalWrite(A1, HIGH);
    digitalWrite(A2, HIGH);    
    return;
  }
  digitalWrite(A1, LOW);
  digitalWrite(A2, LOW);   
 
}


int picktocolor (char pick){

    if (pick == 0)
    {
      return RED;
    }
    if (pick == 1)
    {
      return BLUE;
    }
    if (pick == 2)
    {
      return ORANGE;
    }
    if (pick == 3)
    {
      return GREEN;
    }
    if (pick == 4)
    {
      return PURPLE;
    }

    return WHITE;  

}


void turn(int degree)
{
  if(degree < 0)
  { 
    degree *= -1;
    motorleft.run(255);
    motorright.run(255);
  }
  else
  {
    motorleft.run(-255);
    motorright.run(-255);
  }
  delay(TURNDURATION * degree);
  motorleft.run(0);
  motorright.run(0);
  delay(50);
  motorleft.run(vleft);
  motorright.run(vright);
}



//uint16_t rightsensor()
//{
//  return ultrasonic.distanceCm();
//}




void steer(int n)             //-ve n to steer left, +ve n to steer right
{
  if(n < 0)
  {
    motorleft.run(-240 - (n));  //steer left
    motorright.run(255);
  }
  else
  {
    motorleft.run(-240);
    motorright.run(255 - (n));  //steer right
  }
}



void onegridforward()
{
  motorleft.run(vleft);
  motorright.run(vright);
  delay(oneduration);
  motorleft.stop();
  motorleft.stop();
  delay(100);
}



bool line()
{
  switch(linesensor.readSensors())
  {
    case S1_OUT_S2_OUT: 
    motorleft.run(vleft);
    motorright.run(vright);
    return false;
    case S1_IN_S2_OUT: 
    motorleft.run(0);
    motorright.run(0);
    delay(20);
    return true;
    case S1_OUT_S2_IN: 
    motorleft.run(0);
    motorright.run(0);
    delay(20);
    return true;
    case S1_IN_S2_IN: 
    motorleft.run(0);
    motorright.run(0);
    return true;
  }
}


void music()
{
  for(int i = 1; i <= 1; i += 1)
  {
    int freq = 600;
    while(freq < 800)
    {
      buzzer.tone(freq, 10);
      freq += 1;
    }
    delay(20);
    while(freq > 600)
    {
      buzzer.tone(freq, 10);
      freq -= 1;
    }
    delay(20);
  }
  buzzer.noTone();
}




long time = 0;



void setup()
{
pinMode(COLOR_IN, INPUT);  //colour
pinMode(IR_IN, INPUT);  //left
pinMode(A1, OUTPUT); //2-4 x1
pinMode(A2, OUTPUT); //2-4 x2
  
  Serial.begin(9600);
  motorleft.run(vleft);
  motorright.run(vright);
  delay(300);
//  rightdistance = (int) rightsensor.distanceCm();
  rightdistance = ultrasonic.distanceCm();
  leftdistance = analogRead(IR_IN);
  delay(10);
}











void loop()
{ 
  newrightdistance = ultrasonic.distanceCm();
  if(newrightdistance < 6)
  {
    steer(-80);
  }
  else if(newrightdistance < 10)
  {
    steer(20 * (newrightdistance - rightdistance));
  }
  newleftdistance = analogRead(IR_IN);
  Serial.println(newleftdistance);
  Serial.println(newrightdistance);
  if(newleftdistance < 420)
  {
    steer(80);
  }
  rightdistance = newrightdistance;
  leftdistance = newleftdistance;
  if(line()&& millis() - time > 1000)
  {
    time = millis();
    int angle = picktocolor(color_sensor.color_picker());
  if(angle == -2)
 {
    turn(left);
    onegridforward();
    turn(left);
  }
  else if(angle == 2)
  {
    turn(right);
    onegridforward();
    turn(right);
  }
 // else if(angle == 0)
//  {
//    music();
//  }
  else
  {
    turn(angle);
  }
  }
  
  
  
 


 
}
